l### Clean Data and run the process

source("./cov_me/Functions.R")

## Change data <- totstock to run on the machine 
## Query on the shortstock including just variables of interest

data <- shortstock
data$date  <- as.Date(strptime(as.character(data$date), "%d/%m/%Y"))
data$COMNAM <- as.character(data$COMNAM)
data$RET <- as.numeric(as.character(data$RET))
## define one vector for each stock: 
## use return of single stock as shortstock$ewretd
## use market return as sortstock$sprtr  (ASSUMPTION mkt return and index return coincides)
## All other variables should be dropped!

## Vector of market returns

mktreturn <- as.data.frame(cbind(mkt_return = data[!duplicated(data$date),]$sprtr, date= as.character(data[!duplicated(data$date),]$date)))
companynames <- as.character(unique(data$COMNAM))

## To be fixed: We need the dayly return on US bonds
## Name the data
USInterest <- TreasuryReturnsUS

## Use the Treasury bills return: note to create the dayly we use the compound formula
daylyriskfreerate <- (1 + as.numeric(USInterest$X1month)/100)^(1/30) - 1 
risk_free_matrix <- as.data.frame(cbind(rf=daylyriskfreerate, date=as.character(USInterest[,1])))

## Make the dates comparable between the 2 datasets
risk_free_matrix[,2] <- paste0("20",substr(as.character(risk_free_matrix[,2]), 7 , 9),
                               "-",substr(as.character(risk_free_matrix[,2]), 0 , 2),"-",
                               substr(as.character(risk_free_matrix[,2]), 4 , 5)) 


## Screen and pick only the ones in the same date of mkreturn
risk_free_matrix <- risk_free_matrix[as.character(risk_free_matrix$date) %in% as.character(mktreturn[,2]),]

## Drop observation in mktreturn not in risk_free_matrix
mktreturn <- mktreturn[as.character(mktreturn[,2]) %in% as.character(risk_free_matrix$date),]
returns <- merge(mktreturn, risk_free_matrix, by="date")
returns$mkt_return <- as.numeric(as.character(returns$mkt_return))
returns$rf <- as.numeric(as.character(returns$rf))
returns$date <- as.Date(strptime(as.character(returns$date), "%Y-%m-%d"))



noCores <- detectCores() - 1
registerDoMC(noCores)

## Compute the out of sample variance on a larga class of alpha

alpha <- seq(from = 0.1, to = 1, by=0.1)
variances <- foreach(alpha=alpha, .combine=cbind)%dopar%{
  cross_validate(data,returns,4,alpha, 0.01)}
mspe <- apply(variances, 2, function(x)(mean(x,na.rm=TRUE)))

write.table(mspe, "./Results_CV.txt")
vv <- which.min(mspe[seq(from=1, to=length(mspe), by=4)])

## Look for the minimum here
alpha_2 <- seq(from=(seq(from = 0.1, to = 1, by=0.1)[vv] - 0.05), to=(seq(from = 0.1, to = 1, by=0.1)[vv] + 0.05), by=0.01)
variances <- foreach(alpha=alpha_2, .combine=cbind)%dopar%{
  cross_validate(data,returns,4,alpha, 0.01)}

plot(x= alpha_2,y=mm[seq(from=1, to=length(mm), by=4)], 
     main="Cross validation in the minumum region", xlab="alpha", ylab="Variance", type="n")
lines(x= alpha_2,y=mm[seq(from=1, to=length(mm), by=4)], col="red", lwd=2)


## Asyntodic alpha from Wolf and Ledoit
X_centered <- apply(X, 2, function(x)(x - mean(x)))



p <- foreach(i = 1:(dim(X)[2]-1), .combine= function(x,y)(sum(x,y))) %dopar%{
  foreach(n = (i+1):dim(X)[2], .combine =function(x,y)(sum(x,y))) %dopar%{
    sum((X_centered[,i]*X_centered[,n] - S[i,n])^2)*1/dim(X)[1]  }
}




registerDoSEQ()
